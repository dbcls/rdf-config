require_relative '../model'
require_relative '../model/subject'
require_relative '../model/value_list'
require_relative 'base'
require_relative 'common_methods'
require_relative 'data_type'

class RDFConfig
  class Grasp
    class DatasetTypeGenerator < Base
      include CommonMethods
      include DataType

      DEFAULT_TYPE_NAME = 'Dataset'.freeze

      def initialize(config, opts = {})
        super

        @obj_no = 1
      end

      def generate
        lines = ["type #{graphql_type_name} {"]
        lines += data_type_lines
        lines << '}'

        lines
      end

      private

      def graphql_type_name
        subject_type_name(@config, @subject, add_namespace: @add_namespace)
      end

      def data_type_lines
        lines = ["#{INDENT}#{IRI_ARG_NAME}: String!"]
        triples.each do |triple|
          object_name = triple.object_name.to_s.strip
          if object_name.empty?
            object_name = "obj#{@obj_no}"
            @obj_no += 1
            # warn "      Empty object name -> #{object_name}"
          elsif /\A\w+\z/ !~ triple.object_name
            orig_object_name = object_name
            object_name = object_name.gsub(/\W/, '_')
            # warn "      Object #{orig_object_name} -> #{object_name}"
          end
          lines << "#{INDENT}#{object_name}: #{data_type_desc(triple)}"
        end

        lines
      end

      def data_type_desc(triple)
        desc = data_type_by_triple(triple)
        desc = "#{desc}!" if triple.predicate.required?
        desc = "[#{desc}]" unless triple.predicates.select(&:plural?).empty?

        desc
      end

      def data_type_by_triple(triple)
        case triple.object
        when Model::Subject
          data_type_by_subject(triple)
        when Model::ValueList
          data_type_by_value_list(triple)
        else
          data_type_by_normal_object(triple.object)
        end
      end

      def data_type_by_subject(triple)
        force_array_type(
          subject_type_name(@config, triple.object, add_namespace: @add_namespace),
          triple.predicate.plural?
        )
      end

      def data_type_by_value_list(triple)
        subjects = triple.object.value.select { |value| value.is_a?(Model::Subject) }
        num_subjects = subjects.size
        if num_subjects > 1
          # type is union
          force_array_type(union_type_name(@config, triple.object), triple.predicate.plural?)
        elsif num_subjects == 1
          # type name is generated by subject name
          force_array_type(
            subject_type_name(@config, subjects.first, add_namespace: @add_namespace),
            triple.predicate.plural?
          )
        else
          data_type_by_normal_object(triple.object.value.first)
        end
      end

      def data_type_by_normal_object(object)
        case object.type
        when 'URI'
          'String'
        when 'Int', 'Float'
          object.type
        when 'TrueClass', 'FalseClass'
          'Boolean'
        else
          'String'
        end
      end

      def dataset_subject
        @subject
      end

      def force_array_type(type_name, is_plural)
        if is_plural
          type_name
        else
          "[#{type_name}]"
        end
      end
    end
  end
end
